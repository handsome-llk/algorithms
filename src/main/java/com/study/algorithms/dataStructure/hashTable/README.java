package com.study.algorithms.dataStructure.hashTable;

public class README {
    /**
     * 散列函数：
     * 1、除法散列法
     * 2、乘法散列法
     * 3、全域散列法
     * 4、开放寻址法
     * 5、完全散列
     */

    /**
     * 触发散列法：
     * h(k) = k mod m
     * 散列表槽数(m)最好不要选择2的次幂。。。
     * 但是我觉得就算散列表大小是7这种。。。如果域里全是1,8,15...这样的也会有同样的问题。。
     * 可能是2次幂的数用的比较多？
     */

    /**
     * 乘法散列法：
     * h(k) = m * (A * k - ((int) A * k));
     * A(0 < A < 1)是一个常数
     * m 一般取2的某个幂次
     */

    /**
     * 全域散列法：
     * 按我的理解就是每一次初始化时随机选择一种散列法。。。防止被恶意攻击。。。。
     */

    /**
     * 开放寻址法：
     *
     * 说下我对下列函数的理解，比如h(k, i) = (h'(k) + i) mod m
     * 先散列h'(k)定位，如果槽中有数据了，就先加i再mod m看槽中是否有数据。i从0 -> m - 1直到找到空槽
     *
     * 1、按我的理解就是现根据h(k, i) =（h'(k) + i） mod m定位到一个索引，如果该索引有数据了，
     *      则往后顺延直到找到空槽，这叫线性探查。
     * 2、当然不一定是往后顺延，h(k, i) = (h'(k) + c1 * i + c2 * i^2) mod 2这叫二次探查。
     * 3、还有一个是h(k, i) = (h1(k) + i * h2(k)) mod m根据位置i进行双重散列定位，这叫双重散列。
     *      双重散列h2(k)不能被m整除，否则就没有意义了，最好连公约数都没有。
     * 我觉得其实差不多。。只要冲突了都会把数据堆到一起。。。
     * m是散列表大小
     * i = 0, 1, ..., m-1;
     */

    /**
     * 完全散列：
     *
     * 按我的理解，完全散列和散列槽嵌链表是很类似的。
     * 但是完全散列槽中不是以链表的形式解决冲突的，而是以二级散列表解决一级冲突。
     * 以及我觉得二级散列也没法完全解决冲突，还是要用开放寻址法来解决二级冲突。
     *
     */

}
