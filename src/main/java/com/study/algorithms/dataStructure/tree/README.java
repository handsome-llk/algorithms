package com.study.algorithms.dataStructure.tree;

import java.util.HashMap;

public class README {

    /**
     * 1、二叉搜索树
     */

    /**
     * 二叉搜索树：
     *
     * 对于任何结点x，其左子树中的关键字最大不超过x.key，其右子树中的关键字最小不低于x.key。
     * 最大关键字元素和最小关键字元素。
     * 在二叉搜索树中最大关键字元素通常是树中最最右下角的节点。最小关键字元素通常是树中最最左下角的节点。
     *
     * 这里有两个概念：后继和前驱
     * 后继：x的后继指的是这棵树中比x大的最小值。通常是x右子树的最小关键字元素。若右子树为空。。嗯。。自己想想。
     *
     * 前驱和后继这两个概念在完成删除节点时会很有用
     *
     */

    /**
     * 红黑树：
     *
     * 树中每个结点至少包含5个属性:color、key、left、right、p。如果一个节点没有子结点或者父结点，该结点的left或者
     * right或者p指向null。我们可以把这些null视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为
     * 树的内部结点。
     *
     * 一棵红黑树是满足下面红黑性质的二叉搜索树：
     * 1、每个结点或是红色的，或是黑色的。
     * 2、根结点是黑色的。
     * 3、每个叶结点（null）是黑色的。
     * 4、如果一个结点是红色的，则它的两个子结点都是黑色的。
     * 5、对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。
     *
     * 为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表null。对于一棵红黑树T，哨兵T.null是一个与树中普通结点
     * 有相同属性的对象。它的color属性为BLACK，而其他属性p、left、right和key可以设为任意值。当然为每个叶结点以及
     * 根结点的父结点设置一个T.null是很浪费空间的，取而代之的是，使用一个哨兵T.null来代表所有的null：所有的叶结点
     * 和根结点的父结点。哨兵的属性p、left、right和key并不重要。
     *
     * 黑高：从某个结点x触发（不包含该结点）到达一个叶结点的任意一条简单路径上的黑色结点的个数，记为bh(x)。黑高的概念
     * 是明确定义的，因为从该结点出发的所有下降到其叶结点的简单路径的黑结点个数都相同。于是定义红黑树的黑高为其根结点
     * 的黑高。
     *
     * 左旋：逆时针旋转
     * 右旋：顺时针旋转
     *
     * 将新结点加入后，使用以下方法调整红黑树性质。
     * RB-INSERT-FIXUP(T, z)
     *
     * while (z.p.color == RED) {
     * 	if (z.p == z.p.p.left) {
     * 		y = z.p.p.right
     * 		if (y.color == RED) {
     * 			z.p.color = BLACK
     * 			y.color = BLACK
     * 			z.p.p.color = RED
     * 			z = z.p.p
     *                } else if (z == z.p.right) {
     * 			z = z.p
     * 			左旋(z)
     *        } else {
     * 			z.p.color = BLACK
     * 			z.p.p.color = RED
     * 			右旋(z.p.p)
     *        }
     *  } else {
     * 	    和上边反一下
     * 	}
     * }
     * T.root.color = BLACK
     *
     * 红黑树问题说明：(图片见redBlack/red_black_tree_1.png)
     *
     * 第一种情况是叔结点和父结点都是红色的，所以将父结点和叔结点染黑，z.p.p染红(因为叔结点是红的，所以z.p.p原先必定是黑的)。
     * 保持各条路的黑结点一样多。因为z.p.p变红，所以要考虑z.p.p.p是否为红，所以将z.p.p赋给z，循环以上逻辑
     *
     * 第二种情况直接将z变黑是有问题的，z.p.p右子树的黑色结点就会比z这条路少一个。所以这里的操作是将z并入z.p和z.p.p之间，也就是
     * 左旋z.p达到这种效果，此时z.p.p左子树的黑色结点与右子树的黑色结点一样多。此时就处于第三种情况。
     *
     * 第三种情况将z.p染黑，z.p.p染红，右旋z.p.p。（z.p是z.p.p的左子树，则z.p.p需要右旋解决黑红红的问题）。其实第二种操作
     * 就是将第二种情况变为第三种情况。
     *
     * 这样就在各条路给结点总量不变的情况下，符合了所有性质。
     *
     * 其实以上的处理全部都是围绕一个关键点进行的，假设新增结点node,这个关键点是node加入后,node.p.p到任一叶结点的黑结点个数
     * 与原先保持一致。
     *
     */

    /**
     * hashMap源码：
     *
     * 当某条链表长度超过8，但散列表长度小于64时，会重组hashMap，扩展散列长度。
     * 个人理解是将散列表长度乘以2，再将所有数据重新写进去
     *
     * 当某条链表长度超过8，且散列表长度大于等于64时，链表会变为红黑树。
     *
     * 散列长度是在首次put时生成，初始长度为16。
     * 且从上面可以看出hashMap中散列表的最长长度为64.
     *
     * 以上考虑的没有包括偏移值，但大致思路是这样的。
     *
     */

}
