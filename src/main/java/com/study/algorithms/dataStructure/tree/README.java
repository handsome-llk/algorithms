package com.study.algorithms.dataStructure.tree;

import java.util.HashMap;
import java.util.concurrent.locks.ReentrantLock;

public class README {

    /**
     * 1、二叉搜索树
     */

    /**
     * 二叉搜索树：
     *
     * 对于任何结点x，其左子树中的关键字最大不超过x.key，其右子树中的关键字最小不低于x.key。
     * 最大关键字元素和最小关键字元素。
     * 在二叉搜索树中最大关键字元素通常是树中最最右下角的节点。最小关键字元素通常是树中最最左下角的节点。
     *
     * 这里有两个概念：后继和前驱
     * 后继：x的后继指的是这棵树中比x大的最小值。通常是x右子树的最小关键字元素。若右子树为空。。嗯。。自己想想。
     *
     * 前驱和后继这两个概念在完成删除节点时会很有用
     *
     */

    /**
     * 遍历：
     * 1、前序遍历：根左右
     * 2、中序遍历：左根右
     * 3、后序遍历：左右根
     */

    /**
     * 红黑树：
     *
     * 树中每个结点至少包含5个属性:color、key、left、right、p。如果一个节点没有子结点或者父结点，该结点的left或者
     * right或者p指向null。我们可以把这些null视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为
     * 树的内部结点。
     *
     * 一棵红黑树是满足下面红黑性质的二叉搜索树：
     * 1、每个结点或是红色的，或是黑色的。
     * 2、根结点是黑色的。
     * 3、每个叶结点（null）是黑色的。
     * 4、如果一个结点是红色的，则它的两个子结点都是黑色的。
     * 5、对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。
     *
     * 为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表null。对于一棵红黑树T，哨兵T.null是一个与树中普通结点
     * 有相同属性的对象。它的color属性为BLACK，而其他属性p、left、right和key可以设为任意值。当然为每个叶结点以及
     * 根结点的父结点设置一个T.null是很浪费空间的，取而代之的是，使用一个哨兵T.null来代表所有的null：所有的叶结点
     * 和根结点的父结点。哨兵的属性p、left、right和key并不重要。
     *
     * 黑高：从某个结点x触发（不包含该结点）到达一个叶结点的任意一条简单路径上的黑色结点的个数，记为bh(x)。黑高的概念
     * 是明确定义的，因为从该结点出发的所有下降到其叶结点的简单路径的黑结点个数都相同。于是定义红黑树的黑高为其根结点
     * 的黑高。
     *
     * 左旋：逆时针旋转
     * 右旋：顺时针旋转
     *
     * 将新结点加入后，使用以下方法调整红黑树性质。
     * RB-INSERT-FIXUP(T, z)
     *
     * while (z.p.color == RED) {
     * 	if (z.p == z.p.p.left) {
     * 		y = z.p.p.right
     * 		if (y.color == RED) {
     * 			z.p.color = BLACK
     * 			y.color = BLACK
     * 			z.p.p.color = RED
     * 			z = z.p.p
     *                } else if (z == z.p.right) {
     * 			z = z.p
     * 			左旋(z)
     *        } else {
     * 			z.p.color = BLACK
     * 			z.p.p.color = RED
     * 			右旋(z.p.p)
     *        }
     *  } else {
     * 	    和上边反一下
     * 	}
     * }
     * T.root.color = BLACK
     *
     * 红黑树问题说明：(图片见pic/redBlack/red_black_tree_1.png)
     *
     * 第一种情况是叔结点和父结点都是红色的，所以将父结点和叔结点染黑，z.p.p染红(因为叔结点是红的，所以z.p.p原先必定是黑的)。
     * 保持各条路的黑结点一样多。因为z.p.p变红，所以要考虑z.p.p.p是否为红，所以将z.p.p赋给z，循环以上逻辑
     *
     * 第二种情况直接将z变黑是有问题的，z.p.p右子树的黑色结点就会比z这条路少一个。所以这里的操作是将z并入z.p和z.p.p之间，也就是
     * 左旋z.p达到这种效果，此时z.p.p左子树的黑色结点与右子树的黑色结点一样多。此时就处于第三种情况。
     *
     * 第三种情况将z.p染黑，z.p.p染红，右旋z.p.p。（z.p是z.p.p的左子树，则z.p.p需要右旋解决黑红红的问题）。其实第二种操作
     * 就是将第二种情况变为第三种情况。
     *
     * 这样就在各条路给结点总量不变的情况下，符合了所有性质。
     *
     * 其实以上的处理全部都是围绕一个关键点进行的，假设新增结点node,这个关键点是node加入后,node.p.p到任一叶结点的黑结点个数
     * 与原先保持一致。
     *
     * TODO LILK 红黑树删除节点还没写
     *
     */

    /**
     * 2-3树的红黑树
     *
     * 定义：
     * 1、红链接均为左链接
     * 2、没有任何一个结点同时和两条红链接相连
     * 3、该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同
     *
     * TODO LILK 2-3红黑树删除节点还没写
     *
     */

    /**
     * hashMap源码：
     *
     * 当某条链表长度超过8，但散列表长度小于64时，会重组hashMap，扩展散列长度。
     * 个人理解是将散列表长度乘以2，再将所有数据重新写进去
     *
     * 当某条链表长度超过8，且散列表长度大于等于64时，链表会变为红黑树。
     *
     * 散列长度是在首次put时生成，初始长度为16。
     * 且从上面可以看出hashMap中散列表的最长长度为64.
     *
     * 以上考虑的没有包括偏移值，但大致思路是这样的。
     *
     */

    /**
     * B树：
     *
     * 一棵b树T是具有以下性质的有根树(根为T.root)：
     * 1、每个结点x有下面属性：
     *  a、x.n，当前存储在结点x中的关键字个数。
     *  b、x.n个关键字本身x.key1,x.key2,...,x.keyx.n，以非降序存放,使得x.key1<=x.key2<=...<=x.keyx.n
     *  c、x.leaf，一个布尔值，如果x是叶结点，则为true；如果x为内部结点，则为false
     *
     * 2、每个内部结点x还包含x.n+1个指向其孩子的指针x.c1,x.c2,...,x.cx.n+1。叶结点没有孩子，所以它们的ci属性
     * 没有定义。
     *
     * 3、关键字x.keyi对存储在各子树中的关键字范围加以分割：如果ki为任意一个存储在以x.ci为根的子树中的关键字，那么：
     * k1<=x.key1<=k2<=x.key2<=...<=x.keyx.n<=kx.n+1
     *
     * 4、每个叶结点具有相同的深度，即树的高度h
     *
     * 5、每个结点所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数t>=2来表示这些界:
     *  a、除了根结点以外的每个结点必须至少有t-1个关键字。因此，除了根结点以外的每个内部结点至少有t个孩子。如果树
     *  非空，根结点至少有一个关键字。
     *  b、每个结点之多可包含2t-1个关键字。因此，一个内部结点至多可有2t个孩子。当一个结点恰好有2t-1个关键字时，
     *  称该结点是满的(full)
     *
     * t=2时的B树是最简单的。每个内部结点有2个、3个或4个孩子，即一棵2-3-4树。然而在实际中，t的值越大，B树的高度
     * 就越小
     *
     */

}
