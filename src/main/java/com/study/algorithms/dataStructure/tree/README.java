package com.study.algorithms.dataStructure.tree;

import java.util.HashMap;

public class README {

    /**
     * 1、二叉搜索树
     */

    /**
     * 二叉搜索树：
     *
     * 对于任何结点x，其左子树中的关键字最大不超过x.key，其右子树中的关键字最小不低于x.key。
     * 最大关键字元素和最小关键字元素。
     * 在二叉搜索树中最大关键字元素通常是树中最最右下角的节点。最小关键字元素通常是树中最最左下角的节点。
     *
     * 这里有两个概念：后继和前驱
     * 后继：x的后继指的是这棵树中比x大的最小值。通常是x右子树的最小关键字元素。若右子树为空。。嗯。。自己想想。
     *
     * 前驱和后继这两个概念在完成删除节点时会很有用
     *
     */

    /**
     * 红黑树：
     *
     * 树中每个结点至少包含5个属性:color、key、left、right、p。如果一个节点没有子结点或者父结点，该结点的left或者
     * right或者p指向null。我们可以把这些null视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为
     * 树的内部结点。
     *
     * 一棵红黑树是满足下面红黑性质的二叉搜索树：
     * 1、每个结点或是红色的，或是黑色的。
     * 2、根结点是黑色的。
     * 3、每个叶结点（null）是黑色的。
     * 4、如果一个结点是红色的，则它的两个子结点都是黑色的。
     * 5、对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。
     *
     * 为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表null。对于一棵红黑树T，哨兵T.null是一个与树中普通结点
     * 有相同属性的对象。它的color属性为BLACK，而其他属性p、left、right和key可以设为任意值。当然为每个叶结点以及
     * 根结点的父结点设置一个T.null是很浪费空间的，取而代之的是，使用一个哨兵T.null来代表所有的null：所有的叶结点
     * 和根结点的父结点。哨兵的属性p、left、right和key并不重要。
     *
     * 黑高：从某个结点x触发（不包含该结点）到达一个叶结点的任意一条简单路径上的黑色结点的个数，记为bh(x)。黑高的概念
     * 是明确定义的，因为从该结点出发的所有下降到其叶结点的简单路径的黑结点个数都相同。于是定义红黑树的黑高为其根结点
     * 的黑高。
     *
     */

    /**
     * hashMap源码：
     *
     * 当某条链表长度超过8，但散列表长度小于64时，会重组hashMap，扩展散列长度。
     * 个人理解是将散列表长度乘以2，再将所有数据重新写进去
     *
     * 当某条链表长度超过8，且散列表长度大于等于64时，链表会变为红黑树。
     *
     * 散列长度是在首次put时生成，初始长度为16。
     * 且从上面可以看出hashMap中散列表的最长长度为64.
     *
     * 以上考虑的没有包括偏移值，但大致思路是这样的。
     *
     */

}
